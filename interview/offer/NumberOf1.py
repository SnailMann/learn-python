class NumberOf1:
    """
    剑指Offer | 面试题15 ： 二进制中1的个数
    请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。
    例如输入数值9，则函数输出2；因为9的二进制是1001，有两位1
    """

    @staticmethod
    def method1(num):  # 方法一，有缺陷，负数会导致死循环
        """
        1. 本方法的原理是，每次使用num & 1判断num的二进制最右位，是否是1。每轮判断完之后， 将num右移1位，既原最右位自丢失，原次右位成为最新最右位。既每次判断num的一位，直到num = 0结束循环
        2. 只用用于统计处理无符号的二进制，既只能处理正数，无法处理负数
        3. 为什么num&1 + num>>1 可以判断二进制的每一位是1还是1？其实num&1也可以判断奇偶性，结果是1基数，0是偶数。因为二进制的奇数的最右边最低位肯定是1,既2^0=1
        4. 如果为负数的话，有符号位右移，假设是8位，一直右移，超过8位后，就会一直得到的都是11111111的补码，转换为原码就是10000001,也即是-1,也就永远无法满足while(num)的条件
        """
        count = 0
        while num:  # num大于0
            if num & 1:  # num % 2取余,如果等于1，则代表num的二进制形式，最右位必定是1
                count += 1
            num >>= 1  # 每判断完最右位，就右移一位，让原本的第二右位成为下轮的最右位
        print(count)

    @staticmethod
    def method2(num):  # 方法二，改进型，解决了负数无限循环问题，但时间复杂度为O(n)，n是二进制的位数
        """
        1. 为了解决num为负整的无限死循环问题。我们就不再右移num.而是定义一个flag，从2^0 = 1开始对应num的最右位，然后flag << 1 = 2^1，与次右位相与，判断次右位是否是1，依次类推
        2. 原理是-> 既num不再变化，而是根据与2^n相与。这里有一个结论就是num & 2^n 大于0，那么num的二进制的从右边数第n + 1位就为1。
        3. 为什么左移就解决了问题呢？因为这也涉及到二进制位运算的知识了。二进制左移运算，低位都是补0，不需要担心正负数问题。而右移运算需要根据是否有符号执行不同的规则
        4. 虽然这里解决了负数问题，但是时间复杂度是O(n)，遍历比较多。flag是无符号的32位int，那么n就是32。是无符号的64位long,那么n就是64。
        """
        count = 0
        flag = 1
        while flag & 31:  # flag & 31是模拟书中c的代码，32位的无符号的int类型，如果是flag等于2^32时，最高位超过32，自然丢失，变成0
            if num & flag:
                count += 1
            flag <<= 1
        print(count)

    @staticmethod
    def method3(num):  # 方法三，最高效的解决方法
        """
        1. 本方法的好处就是，num的二进制有几位是1，就只循环几次，而且没有负数问题
        2. 方法原理是基于： 假设num的从右往左数的第1位为1的数在第m位，那么num & (num -1)得到的结果等于把整数num的二进制的最右边的1变成0。如1100 & (1100 - 1) = 1100 & (1011) = 1000
        3. 所以每次循环，每次num都去掉一个最右边的一个1。直到num = 0，无1可去退出循环
        """
        count = 0
        while num & 31:
            count += 1
            num = (num - 1) & num
        print(count)


class NumberOf2Power:
    """
    剑指Offer | 二进制中1的个数的相关问题
    用一句话判断一个整数是不是2的整数次方
    """

    @staticmethod
    def method1(num):
        """
        1. 原理是，一个整数如果是2的整数次方，那么它的二进制表示中有且只有一个1，其他位必然是0，比如2 = 0b10; 16 = 0b1000; 128 = 0b1000000。
        根据前面"二进制中1的个数"的最佳方法分析，只需要把该整数减1后再和自己相与的结果是否等于0，就可以得出结论
        """
        print(True if (num & (num - 1)) == 0 else False)


class NumberOfMAndN:
    """
    剑指Offer | 二进制的1的个数的相关问题
    输入两个整型m和n, 计算需要改变m的二进制的多少位，才能变成n
    比如, m = 10 = 0b1010，n = 13 = 0b1101 ,m -> n需要改变三位
    """

    @staticmethod
    def methon1(n, m):
        """
        1. 原理是，二进制无非就是将1变为0,0变为1，所以要看m变成n，需要改变几位，只需要知道m和n的二进制对应位值不同的有几个，所以我们可以分为两步
        (1) m ^ n求异或，相同为0，不同为1，然后我们就可以得到m和n的异或值，异或值有多少个1，就修改改变几位，怎么知道异或值有几个1呢？这就变原题了
        (2) 求异或值中有多少个1 NumberOf1.method1(异或值)
        """
        result = NumberOfMAndN.__number_of_1(n ^ m)
        print(result)

    @staticmethod
    def __number_of_1(num):
        count = 0
        while num:
            count += 1
            num = num & (num - 1)
        return count


if __name__ == '__main__':
    NumberOf1.method2(-10)
    NumberOf1.method3(-10)
    # NumberOf2Power.method1(16)
    # NumberOfMAndN.methon1(10, 13)
